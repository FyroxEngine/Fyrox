use crate::{
    inspector::editors::make_property_editors_container, message::MessageSender,
    scene::EditorScene, Engine, MSG_SYNC_FLAG,
};
use fyrox::{
    core::{log::Log, pool::Handle, reflect::prelude::*, scope_profile},
    gui::{
        button::{ButtonBuilder, ButtonMessage},
        grid::{Column, GridBuilder, Row},
        inspector::{InspectorBuilder, InspectorContext, InspectorMessage, PropertyAction},
        message::{MessageDirection, UiMessage},
        scroll_viewer::ScrollViewerBuilder,
        widget::WidgetBuilder,
        window::{WindowBuilder, WindowTitle},
        Thickness, UiNode,
    },
    utils::lightmap::Lightmap,
};
use std::{path::PathBuf, rc::Rc};

#[derive(Reflect, Debug)]
struct LightmapperSettings {
    #[reflect(
        description = "Amount of texels per unit. It defines 'pixels density' per unit of area (square meters). The \
    more the value, the more detailed produced light map will be and vice versa. This value **directly** affects performance \
    in quadratic manner, which means that if you change it from 32 to 64, the time needed to generate the light map won't double, \
    but it will be 4 times more. Default value is 64 which is a good balance between quality and generation speed.",
        min_value = 1.0,
        max_value = 256.0
    )]
    texels_per_unit: u32,
    #[reflect(
        description = "Relative spacing between UV elements generated by the built-in UV mapper. The more the value, the \
    more the distance between the UV elements will be. This parameters is used to prevent seams from occurring, when rendering \
    meshes with bilinear filtration. Default value is 0.005, which is a good balance between size of the light maps and their \
    quality (lack of seams).",
        min_value = 0.0,
        max_value = 0.1,
        step = 0.001
    )]
    spacing: f32,
    #[reflect(
        description = "Path to the directory which will be used to save the generated light maps. Keep in mind, that \
    the lightmapper automatically generates names for the files."
    )]
    path: PathBuf,
}

impl Default for LightmapperSettings {
    fn default() -> Self {
        Self {
            texels_per_unit: 64,
            spacing: 0.005,
            path: Default::default(),
        }
    }
}

pub struct LightPanel {
    pub window: Handle<UiNode>,
    inspector: Handle<UiNode>,
    generate: Handle<UiNode>,
    settings: LightmapperSettings,
}

impl LightPanel {
    pub fn new(engine: &mut Engine, sender: MessageSender) -> Self {
        let settings = LightmapperSettings::default();
        let container = Rc::new(make_property_editors_container(sender));

        let generate;
        let inspector;
        let ctx = &mut engine.user_interface.build_ctx();
        let window = WindowBuilder::new(
            WidgetBuilder::new()
                .with_name("LightPanel")
                .with_width(300.0)
                .with_height(400.0),
        )
        .with_title(WindowTitle::Text("Light Settings".to_owned()))
        .open(false)
        .with_content(
            GridBuilder::new(
                WidgetBuilder::new()
                    .with_child(
                        ScrollViewerBuilder::new(
                            WidgetBuilder::new()
                                .with_margin(Thickness::uniform(1.0))
                                .on_row(0),
                        )
                        .with_content({
                            inspector = InspectorBuilder::new(
                                WidgetBuilder::new().with_margin(Thickness::uniform(1.0)),
                            )
                            .with_context(InspectorContext::from_object(
                                &settings,
                                ctx,
                                container,
                                None,
                                MSG_SYNC_FLAG,
                                0,
                                true,
                                Default::default(),
                            ))
                            .build(ctx);
                            inspector
                        })
                        .build(ctx),
                    )
                    .with_child({
                        generate = ButtonBuilder::new(
                            WidgetBuilder::new()
                                .on_row(1)
                                .on_column(0)
                                .with_margin(Thickness::uniform(1.0)),
                        )
                        .with_text("Generate Lightmap")
                        .build(ctx);
                        generate
                    }),
            )
            .add_column(Column::stretch())
            .add_row(Row::stretch())
            .add_row(Row::strict(25.0))
            .build(ctx),
        )
        .build(ctx);

        Self {
            window,
            inspector,
            generate,
            settings,
        }
    }

    pub fn handle_ui_message(
        &mut self,
        message: &UiMessage,
        editor_scene: &EditorScene,
        engine: &mut Engine,
    ) {
        scope_profile!();

        if let Some(ButtonMessage::Click) = message.data::<ButtonMessage>() {
            if message.destination() == self.generate {
                let scene = &mut engine.scenes[editor_scene.scene];

                let lightmap = Lightmap::new(
                    scene,
                    self.settings.texels_per_unit,
                    self.settings.spacing,
                    |handle, _| handle != editor_scene.editor_objects_root,
                    Default::default(),
                    Default::default(),
                )
                .unwrap();
                lightmap
                    .save(&self.settings.path, engine.resource_manager.clone())
                    .unwrap();
                scene.set_lightmap(lightmap).unwrap();
            }
        } else if let Some(InspectorMessage::PropertyChanged(args)) = message.data() {
            if message.destination() == self.inspector
                && message.direction() == MessageDirection::FromWidget
            {
                PropertyAction::from_field_kind(&args.value).apply(
                    &args.path(),
                    &mut self.settings,
                    &mut |result| {
                        Log::verify(result);
                    },
                );
            }
        }
    }
}
